/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2013-2021 Regents of the University of California.
 *
 * This file is part of ndn-cxx library (NDN C++ library with eXperimental eXtensions).
 *
 * ndn-cxx library is free software: you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * ndn-cxx library is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
 *
 * You should have received copies of the GNU General Public License and GNU Lesser
 * General Public License along with ndn-cxx, e.g., in COPYING.md file.  If not, see
 * <http://www.gnu.org/licenses/>.
 *
 * See AUTHORS.md for complete list of ndn-cxx authors and contributors.
 */

#include <ndn-cxx/face.hpp>
#include <ndn-cxx/security/validator-config.hpp>
#include <ndn-cxx/security/key-chain.hpp>
#include <lvs-cxx/lvs-validator.hpp>

#include <iostream>

namespace lvs {
namespace examples {

using ndn::operator""_s;

class Consumer
{
public:
  Consumer(): m_validator(nullptr)
  {
    const ndn::Name anchor_id_name = "/example";
    const auto trust_anchor = m_keyChain.getPib().getIdentity(anchor_id_name)
                                                 .getDefaultKey()
                                                 .getDefaultCertificate();

    // lvs = r'''
    // #root: /"example"
    // #KEY: "KEY"/_/_/_
    // #data: #root/author/_data/_version <= #author_key
    // #author_key: #root/author/"KEY"/_
    // #author_cert: #root/author/#KEY <= #anchor
    // #anchor: #root/#KEY
    // '''
    const uint8_t trust_schema[] = {
      0x40, 0x04, 0x00, 0x01, 0x00, 0x00, 0x03, 0x01, 0x00, 0x43, 0x01, 0x01, 0x41, 0x1F, 0x03, 0x01,
      0x00, 0x31, 0x0E, 0x03, 0x01, 0x01, 0x01, 0x09, 0x08, 0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C,
      0x65, 0x31, 0x0A, 0x03, 0x01, 0x11, 0x01, 0x05, 0x08, 0x03, 0x4B, 0x45, 0x59, 0x41, 0x31, 0x03,
      0x01, 0x01, 0x34, 0x01, 0x00, 0x05, 0x05, 0x23, 0x72, 0x6F, 0x6F, 0x74, 0x31, 0x0A, 0x03, 0x01,
      0x02, 0x01, 0x05, 0x08, 0x03, 0x4B, 0x45, 0x59, 0x32, 0x06, 0x03, 0x01, 0x06, 0x02, 0x01, 0x01,
      0x32, 0x06, 0x03, 0x01, 0x0B, 0x02, 0x01, 0x01, 0x32, 0x06, 0x03, 0x01, 0x0E, 0x02, 0x01, 0x01,
      0x41, 0x0E, 0x03, 0x01, 0x02, 0x34, 0x01, 0x01, 0x32, 0x06, 0x03, 0x01, 0x03, 0x02, 0x01, 0x02,
      0x41, 0x0E, 0x03, 0x01, 0x03, 0x34, 0x01, 0x02, 0x32, 0x06, 0x03, 0x01, 0x04, 0x02, 0x01, 0x03,
      0x41, 0x0E, 0x03, 0x01, 0x04, 0x34, 0x01, 0x03, 0x32, 0x06, 0x03, 0x01, 0x05, 0x02, 0x01, 0x04,
      0x41, 0x0F, 0x03, 0x01, 0x05, 0x34, 0x01, 0x04, 0x05, 0x07, 0x23, 0x61, 0x6E, 0x63, 0x68, 0x6F,
      0x72, 0x41, 0x12, 0x03, 0x01, 0x06, 0x34, 0x01, 0x01, 0x31, 0x0A, 0x03, 0x01, 0x07, 0x01, 0x05,
      0x08, 0x03, 0x4B, 0x45, 0x59, 0x41, 0x0E, 0x03, 0x01, 0x07, 0x34, 0x01, 0x06, 0x32, 0x06, 0x03,
      0x01, 0x08, 0x02, 0x01, 0x02, 0x41, 0x0E, 0x03, 0x01, 0x08, 0x34, 0x01, 0x07, 0x32, 0x06, 0x03,
      0x01, 0x09, 0x02, 0x01, 0x03, 0x41, 0x0E, 0x03, 0x01, 0x09, 0x34, 0x01, 0x08, 0x32, 0x06, 0x03,
      0x01, 0x0A, 0x02, 0x01, 0x04, 0x41, 0x17, 0x03, 0x01, 0x0A, 0x34, 0x01, 0x09, 0x05, 0x0C, 0x23,
      0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x5F, 0x63, 0x65, 0x72, 0x74, 0x33, 0x01, 0x05, 0x41, 0x0E,
      0x03, 0x01, 0x0B, 0x34, 0x01, 0x01, 0x32, 0x06, 0x03, 0x01, 0x0C, 0x02, 0x01, 0x05, 0x41, 0x0E,
      0x03, 0x01, 0x0C, 0x34, 0x01, 0x0B, 0x32, 0x06, 0x03, 0x01, 0x0D, 0x02, 0x01, 0x06, 0x41, 0x10,
      0x03, 0x01, 0x0D, 0x34, 0x01, 0x0C, 0x05, 0x05, 0x23, 0x64, 0x61, 0x74, 0x61, 0x33, 0x01, 0x10,
      0x41, 0x12, 0x03, 0x01, 0x0E, 0x34, 0x01, 0x01, 0x31, 0x0A, 0x03, 0x01, 0x0F, 0x01, 0x05, 0x08,
      0x03, 0x4B, 0x45, 0x59, 0x41, 0x0E, 0x03, 0x01, 0x0F, 0x34, 0x01, 0x0E, 0x32, 0x06, 0x03, 0x01,
      0x10, 0x02, 0x01, 0x07, 0x41, 0x13, 0x03, 0x01, 0x10, 0x34, 0x01, 0x0F, 0x05, 0x0B, 0x23, 0x61,
      0x75, 0x74, 0x68, 0x6F, 0x72, 0x5F, 0x6B, 0x65, 0x79, 0x41, 0x0E, 0x03, 0x01, 0x11, 0x34, 0x01,
      0x00, 0x32, 0x06, 0x03, 0x01, 0x12, 0x02, 0x01, 0x02, 0x41, 0x0E, 0x03, 0x01, 0x12, 0x34, 0x01,
      0x11, 0x32, 0x06, 0x03, 0x01, 0x13, 0x02, 0x01, 0x03, 0x41, 0x0E, 0x03, 0x01, 0x13, 0x34, 0x01,
      0x12, 0x32, 0x06, 0x03, 0x01, 0x14, 0x02, 0x01, 0x04, 0x41, 0x0C, 0x03, 0x01, 0x14, 0x34, 0x01,
      0x13, 0x05, 0x04, 0x23, 0x4B, 0x45, 0x59, 0x42, 0x0B, 0x02, 0x01, 0x01, 0x05, 0x06, 0x61, 0x75,
      0x74, 0x68, 0x6F, 0x72,
    };
    m_validator = std::make_unique<lvs::Validator>(
      tlv::bstring_view(trust_schema, sizeof(trust_schema)),
      m_face,
      trust_anchor);
  }

  void
  run()
  {
    ndn::Name interestName("/example/testApp/randomData");
    interestName.appendVersion();

    ndn::Interest interest(interestName);
    interest.setMustBeFresh(true);
    interest.setInterestLifetime(6_s); // The default is 4 seconds

    std::cout << "Sending Interest " << interest << std::endl;
    m_face.expressInterest(interest,
                           std::bind(&Consumer::onData, this,  _1, _2),
                           std::bind(&Consumer::onNack, this, _1, _2),
                           std::bind(&Consumer::onTimeout, this, _1));

    // processEvents will block until the requested data is received or a timeout occurs
    m_face.processEvents();
  }

private:
  void
  onData(const ndn::Interest&, const ndn::Data& data)
  {
    std::cout << "Received Data " << data << std::endl;

    if(m_validator){
      m_validator->validate(data,
                            [] (const ndn::Data&) {
                              std::cout << "Data conforms to trust schema" << std::endl;
                            },
                            [] (const ndn::Data&, const ndn::security::ValidationError& error) {
                              std::cout << "Error authenticating data: " << error << std::endl;
                            });
    }
  }

  void
  onNack(const ndn::Interest&, const ndn::lp::Nack& nack) const
  {
    std::cout << "Received Nack with reason " << nack.getReason() << std::endl;
  }

  void
  onTimeout(const ndn::Interest& interest) const
  {
    std::cout << "Timeout for " << interest << std::endl;
  }

private:
  ndn::Face m_face;
  ndn::security::KeyChain m_keyChain;
  std::unique_ptr<lvs::Validator> m_validator;
};

} // namespace examples
} // namespace lvs

int
main(int argc, char** argv)
{
  try {
    lvs::examples::Consumer consumer;
    consumer.run();
    return 0;
  }
  catch (const std::exception& e) {
    std::cerr << "ERROR: " << e.what() << std::endl;
    return 1;
  }
}